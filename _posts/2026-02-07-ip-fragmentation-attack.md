---
layout: post
title: "[Network Security] 택배를 쪼개서 검문을 통과한다? IP 파편화 공격 완벽 가이드"
date: 2026-02-07 09:00:00 +0900
categories: [Security, Network]
tags: [IP, Fragmentation, Teardrop, TinyFragment, CS지식, 정보보안기사]
---

# IP 파편화 공격: 조립 설명서를 조작해 서버를 속이는 기술

인터넷 세상에서 데이터는 '패킷'이라는 상자에 담겨 이동합니다. 하지만 모든 도로가 덤프트럭을 수용할 수는 없듯, 네트워크 경로마다 한 번에 보낼 수 있는 데이터 최대 크기(**MTU, Maximum Transmission Unit**)가 정해져 있습니다.

이 MTU보다 큰 패킷이 들어오면 네트워크는 이를 여러 조각으로 나누는데, 이를 **파편화(Fragmentation)**라고 합니다. 공격자들은 바로 이 '조각난 패킷'을 조립하는 서버의 로직을 노립니다.

---

## 0. 파편화(Fragmentation)란 무엇인가?

파편화는 좁은 터널을 지나기 위해 덤프트럭에 실린 짐을 여러 대의 소형 트럭으로 나눠 싣고, 터널 끝에서 다시 합치는 과정과 같습니다.



### ❓ "파편화는 IP(Layer 3)에만 해당하나요?"
**아니요, 하지만 우리가 흔히 말하는 공격은 주로 IP의 특징을 노립니다.**

* **L4 (TCP - 세그멘테이션):** 출발지에서 처음부터 길의 너비(MTU)를 확인해 잘라서 보냅니다. "미리 조심해서 자르자" 주의입니다.
* **L3 (IP - 파편화):** 중간 경로의 라우터가 상황에 따라 **실시간**으로 패킷을 조각냅니다. "가다가 좁으면 거기서 쪼개자" 주의입니다.

공격자들은 바로 이 **실시간으로 쪼개지고 서버에서 합쳐지는 IP 방식의 유연함**을 공략합니다.



---

## 1. 조립 설명서: IP 헤더의 핵심 필드

수신측(서버)이 조각난 패킷을 다시 합치려면 '조립 설명서'가 필요합니다. IP 헤더에는 이를 위한 3가지 핵심 필드가 있습니다.

1.  **Identification (ID):** "우리는 원래 한 몸이야" (ID가 같아야 함)
2.  **MF (More Fragment) Flag:** "뒤에 조각이 더 있어!" (1이면 진행 중, 0이면 마지막 조각)
3.  **Fragment Offset:** "나는 전체 데이터 중 몇 번째 바이트부터 시작해?" (조립 위치 가이드)



---

## 2. Tiny Fragment: "금지 물품 반으로 갈라 숨기기"

방화벽은 보통 **첫 번째 조각($Offset = 0$)**만 보고 "이거 어디 포트로 가네?"를 확인합니다. 이 허점을 노려 포트 정보를 다음 조각으로 밀어버리는 기술입니다.

### ❓ 왜 IP 헤더는 매 조각마다 붙는데, TCP 헤더는 잘리나요?
* **IP 헤더 (송장):** 각 조각이 목적지까지 무사히 가야 하므로, IP 계층은 매 조각 앞에 새로운 송장(IP 헤더)을 무조건 새로 만들어 붙입니다.
* **TCP 헤더 (내용물):** IP 계층 입장에서는 TCP 헤더도 그저 상자 속 **'데이터'**일 뿐입니다. 싹둑 자르라고 하면 내용물이 무엇이든 상관없이 지정된 크기대로 잘라버립니다.

### 💻 패킷 구조 예시
| 패킷 구분 | ID | Offset | Payload Length | 포함된 내용 |
| :--- | :--- | :--- | :--- | :--- |
| **Fragment #1** | 0x1111 | 0 | **8 bytes** | IP 헤더 + TCP 헤더 앞부분 8바이트 (**포트 번호 없음!**) |
| **Fragment #2** | 0x1111 | 1 | 100 bytes | IP 헤더 + **TCP 포트 번호(차단 대상)** + 데이터 |

**결과:** 방화벽은 첫 조각에 포트 번호가 없으니 통과시키고, 두 번째 조각은 검사 없이 통과시켜 결국 차단된 포트(예: 21번 FTP) 접속을 허용하게 됩니다.



---

## 3. Teardrop: "겹쳐진 퍼즐 조각의 저주"

서버가 패킷을 조립할 때 계산을 꼬이게 만들어 시스템을 멈추게(Kernel Panic) 만드는 공격입니다.

### 🛠️ 실제 바이트 계산 예시 (중첩 공격)
* **조각 1:** $Offset = 0$, 길이 $= 100$ (0~99번 데이터)
* **조각 2:** $Offset = 60$, 길이 $= 30$ (60~89번 데이터)

**서버의 계산 루틴:** "어? 2번 조각이 60부터 시작하네? 1번이 이미 100까지 왔는데... 겹치는 부분을 빼야겠다!"
> **계산 공식:** $$(현재 조각 끝점) - (이전 조각 끝점) = 데이터 길이$$
> $$89 - 100 = -11$$

**결과:** 데이터 길이를 계산했는데 **음수($-11$)**가 나옵니다. 이를 예상치 못한 구형 OS는 그대로 블루스크린이 뜨며 죽어버립니다.



---

## 4. Bonk & Boink: "고장 난 레코드판"

서버를 무한 대기 상태로 만들거나 리소스를 고갈시키는 공격입니다.

* **Bonk:** 모든 조각의 $Offset$을 무조건 **1**로 고정해서 보냅니다. 서버는 영원히 완성되지 않는 퍼즐을 붙잡고 다음 조각만 기다리다 지쳐 쓰러집니다.
* **Boink:** 처음엔 정상적으로 보내다가 중간에 **이미 보낸 $Offset$을 다시** 보냅니다. "이미 처리한 구간인데 왜 또 오지?" 하며 예외 처리가 제대로 안 된 시스템을 멈춰버립니다.

---

## 📊 공격 방식 요약 테이블

| 공격명 | 조작 필드 | 핵심 트릭 | 목표 |
| :--- | :--- | :--- | :--- |
| **Tiny Fragment** | Length, Offset | 첫 조각을 헤더보다 작게 분할 | **방화벽 우회** |
| **Teardrop** | Offset | 이전 구간과 겹치게(Overlap) 전송 | **시스템 다운(Panic)** |
| **Bonk / Boink** | Offset | Offset 값을 고정하거나 중복 전송 | **시스템 무력화** |

---

## 🛡️ 방어 전략

1.  **미세 파편 차단:** 첫 번째 조각($Offset=0$)의 크기가 최소 TCP 헤더 크기(20B)보다 작으면 무조건 차단합니다.
2.  **상태 보존형(Stateful) 검사:** 조각들이 다 모일 때까지 기다렸다가 합쳐서 검사하는 똑똑한 보안 장비를 사용합니다.
3.  **최신 OS 패치:** 현대적인 OS 커널은 $Offset$ 중첩이나 음수 길이 에러를 이미 완벽하게 방어하고 있습니다.

---

> **참고**: 본 포스팅은 정보보안기사 실기 시험의 네트워크 보안 파트에서 단골로 출제되는 내용을 기반으로 작성되었습니다.