---layout: post
title: "[JS 기초] 클릭은 한 번 했는데 부모까지 들썩? '이벤트 버블링' 완벽 정리 🫧"
date: 2026-01-29 04:26:02 +0000
categories: [Velog]
original_url: https://velog.io/@iamjaeholee/JS-%EA%B8%B0%EC%B4%88-%ED%81%B4%EB%A6%AD%EC%9D%80-%ED%95%9C-%EB%B2%88-%ED%96%88%EB%8A%94%EB%8D%B0-%EB%B6%80%EB%AA%A8%EA%B9%8C%EC%A7%80-%EB%93%A4%EC%8D%A9-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%B2%84%EB%B8%94%EB%A7%81-%EC%99%84%EB%B2%BD-%EC%A0%95%EB%A6%AC
---
<p>안녕하세요, 예비 개발자 여러분!
오늘은 자바스크립트 이벤트 처리의 핵심이자, 면접 단골 질문인 <strong>&#39;이벤트 버블링(Event Bubbling)&#39;</strong>에 대해 이야기해보려 합니다.</p>
<p>혹시 코드를 짜다가 버튼 하나를 눌렀는데, 의도치 않게 그 버튼을 감싸고 있는 박스나 전체 화면의 클릭 이벤트까지 같이 실행된 경험, 있으신가요? &quot;어? 나 이거 안 눌렀는데?&quot; 하고 당황하셨다면, 오늘 이 글이 그 미스터리를 완벽하게 풀어드릴 겁니다.</p>
<p>자바스크립트가 이벤트를 어떻게 전달하는지, 그리고 이걸 알면 우리 코드가 얼마나 우아해질 수 있는지 함께 알아봅시다.</p>
<hr>
<h2 id="1-이벤트-버블링event-bubbling이란">1. 이벤트 버블링(Event Bubbling)이란?</h2>
<p>이름에서 힌트를 얻어볼까요? <strong>&#39;버블링(Bubbling)&#39;</strong>, 즉 거품입니다.
물속 깊은 곳에서 거품이 생기면 어떻게 되나요? 가만히 있지 않고 수면 위로 뽀글뽀글 올라오죠?</p>
<p>자바스크립트의 이벤트도 똑같습니다.
특정 화면 요소에서 이벤트가 발생하면, 그 이벤트는 거기서 끝나는 게 아니라 <strong>상위 요소(부모)들을 타고 최상위 요소(보통은 <code>window</code>)까지 전파</strong>됩니다. 이 현상을 <strong>이벤트 버블링</strong>이라고 부릅니다.</p>
<blockquote>
<p><strong>💡 한 줄 요약:</strong>
자식 요소에서 발생한 이벤트가 부모 요소를 거쳐 최상위 요소까지 전달되는 현상</p>
</blockquote>
<h3 id="🔍-그림으로-이해하기-dom-트리">🔍 그림으로 이해하기 (DOM 트리)</h3>
<p>여러분이 <code>&lt;div&gt;</code> 안에 있는 <code>&lt;button&gt;</code>을 클릭했다고 상상해 봅시다.</p>
<ol>
<li>사용자가 <code>&lt;button&gt;</code>을 <strong>클릭</strong>합니다.</li>
<li>브라우저는 버튼에 할당된 <code>onclick</code> 이벤트를 실행합니다.</li>
<li>여기서 멈추지 않고, 버튼을 감싸고 있는 <code>&lt;div&gt;</code>의 클릭 이벤트도 실행합니다.</li>
<li>그다음엔 <code>&lt;body&gt;</code>, 그다음엔 <code>&lt;html&gt;</code>, 마지막으로 <code>document</code>까지 올라갑니다.</li>
</ol>
<p>마치 막내(자식)가 사고를 치면 부모님, 조부모님까지 줄줄이 호출되는 것과 비슷하죠? 😂</p>
<hr>
<h2 id="2-이걸-왜-알아야-하나요-핵심-이벤트-위임">2. 이걸 왜 알아야 하나요? (핵심: 이벤트 위임)</h2>
<p>&quot;강사님, 그냥 버튼에만 이벤트 걸면 되지, 굳이 부모한테 전파되는 걸 알아야 하나요? 오히려 불편한 거 아닌가요?&quot;</p>
<p>좋은 질문입니다! 하지만 이 버블링 덕분에 우리는 <strong>&#39;이벤트 위임(Event Delegation)&#39;</strong>이라는 엄청난 기술을 사용할 수 있습니다. 이게 왜 필요한지 두 가지 상황으로 설명해 드릴게요.</p>
<h3 id="①-성능-최적화-메모리-아끼기">① 성능 최적화 (메모리 아끼기)</h3>
<p>쇼핑몰 리스트를 만든다고 가정해 봅시다. 상품이 100개가 있어요.</p>
<ul>
<li><strong>버블링을 모를 때:</strong> 상품 100개 각각에 <code>addEventListener</code>를 붙입니다. (이벤트 리스너 100개 생성 😱)</li>
<li><strong>버블링을 알 때:</strong> 상품을 감싸는 <strong>&#39;부모 요소(울타리)&#39; 하나에만</strong> 이벤트를 붙입니다. (이벤트 리스너 1개 생성 😎)</li>
</ul>
<p>자식들이 클릭 되면 어차피 그 이벤트가 부모에게 올라오(버블링)니까, 부모가 딱 지키고 서서 <strong>&quot;어, 방금 내 자식 중 누가 클릭 됐니?&quot;</strong> 하고 처리하는 거죠. 이게 훨씬 효율적입니다.</p>
<h3 id="②-동적으로-추가된-요소-처리">② 동적으로 추가된 요소 처리</h3>
<p>여러분이 &#39;할 일 목록(To-Do List)&#39;을 만들고 있습니다.
사용자가 &#39;추가&#39; 버튼을 눌러서 새로운 할 일을 만들었어요.</p>
<ul>
<li><strong>문제점:</strong> 페이지 로딩 시점에 없던 새로운 할 일에는 이벤트 리스너가 안 달려 있어서 클릭해도 반응이 없습니다.</li>
<li><strong>해결책:</strong> 부모 요소인 <code>&lt;ul&gt;</code>에 이벤트를 걸어두면, <strong>나중에 추가된 자식(<code>&lt;li&gt;</code>)들이 클릭 되어도</strong> 버블링 덕분에 부모가 알아챌 수 있습니다.</li>
</ul>
<hr>
<h2 id="3-코드로-보는-실전-예제">3. 코드로 보는 실전 예제</h2>
<p>백문이 불여일견! 코드로 직접 확인해 봅시다.</p>
<h3 id="상황-리스트-아이템을-클릭하면-내용을-콘솔에-출력하기">상황: 리스트 아이템을 클릭하면 내용을 콘솔에 출력하기</h3>
<pre><code class="language-javascript">// HTML 구조
// &lt;ul id=&quot;list&quot;&gt;
//   &lt;li class=&quot;item&quot;&gt;아이템 1&lt;/li&gt;
//   &lt;li class=&quot;item&quot;&gt;아이템 2&lt;/li&gt;
//   &lt;li class=&quot;item&quot;&gt;아이템 3&lt;/li&gt;
// &lt;/ul&gt;

const list = document.getElementById(&#39;list&#39;);

// ❌ 나쁜 예: 자식들에게 일일이 이벤트를 붙임 (비효율적)
// const items = document.querySelectorAll(&#39;.item&#39;);
// items.forEach(item =&gt; {
//   item.addEventListener(&#39;click&#39;, () =&gt; { ... });
// });

// ⭕ 좋은 예: 부모(list)에게 이벤트를 위임함
list.addEventListener(&#39;click&#39;, function(event) {
  // event.target: 실제로 클릭된 놈 (자식)
  // event.currentTarget: 이벤트를 듣고 있는 놈 (부모/나)

  // 사용자가 &lt;li&gt;(아이템)를 클릭했을 때만 동작하도록 필터링
  if (event.target.classList.contains(&#39;item&#39;)) {
    console.log(`클릭된 아이템: ${event.target.textContent}`);
  }
});
</code></pre>
<h3 id="⚠️-주의할-점-eventtarget-vs-currenttarget">⚠️ 주의할 점: event.target vs currentTarget</h3>
<p>이벤트 위임을 쓸 때 가장 헷갈리는 부분입니다.</p>
<ul>
<li><strong><code>event.target</code></strong>: 이벤트가 <strong>처음 발생한</strong> 가장 안쪽 요소 (사용자가 진짜 클릭한 것)</li>
<li><strong><code>event.currentTarget</code></strong>: 이벤트를 <strong>현재 처리하고 있는</strong> 요소 (이벤트 리스너가 달린 주인)</li>
</ul>
<p>버블링을 활용할 땐, 부모(<code>currentTarget</code>)가 &quot;누가(<code>target</code>) 클릭 됐는지&quot; 확인하는 과정이 꼭 필요합니다.</p>
<hr>
<h2 id="4-버블링을-막아야-할-때도-있나요-stoppropagation">4. 버블링을 막아야 할 때도 있나요? (<code>stopPropagation</code>)</h2>
<p>물론입니다. 가끔은 &quot;부모님께는 비밀로 해줘!&quot;라고 하고 싶을 때가 있죠.
예를 들어, 팝업창 안의 버튼을 눌렀는데 팝업창 닫기 이벤트(부모)가 실행되면 안 되잖아요?</p>
<p>그럴 땐 <code>event.stopPropagation()</code>을 사용합니다.</p>
<pre><code class="language-javascript">button.addEventListener(&#39;click&#39;, function(event) {
  event.stopPropagation(); // &quot;버블링 멈춰! ✋&quot;
  console.log(&#39;버튼만 클릭됨, 부모로는 전파 안 됨&#39;);
});
</code></pre>
<p>하지만 정말 필요한 경우가 아니라면 남용하지 않는 것이 좋습니다. 나중에 분석 툴을 붙이거나 상위에서 이벤트를 감지해야 할 때, 중간에서 맥이 끊겨버리면 디버깅이 힘들어질 수 있거든요.</p>
<hr>
<h2 id="✨-마무리">✨ 마무리</h2>
<p>오늘 배운 내용을 세 줄로 요약해 볼까요?</p>
<ol>
<li><strong>이벤트 버블링:</strong> 자식 요소의 이벤트가 부모를 타고 최상위까지 전파되는 현상.</li>
<li><strong>이벤트 위임:</strong> 버블링을 이용해 부모에게 이벤트를 한 번만 등록하여 <strong>성능</strong>과 <strong>동적 요소 관리</strong>를 해결하는 기법.</li>
<li><strong>핵심:</strong> <code>event.target</code>(클릭된 놈)을 잘 구분해서 사용하자!</li>
</ol>
<p>이벤트 버블링을 이해하고 나면, 리액트(React)나 뷰(Vue) 같은 프레임워크를 쓸 때도 이벤트 처리가 훨씬 수월해질 거예요. (사실 리액트도 내부적으로 이 원리를 아주 잘 활용하고 있답니다 😉)</p>
<hr>
<h3 id="📚-참고-자료-references">📚 참고 자료 (References)</h3>
<ul>
<li><a href="https://www.google.com/search?q=https://developer.mozilla.org/ko/docs/Learn/JavaScript/Building_blocks/Events%23%25EC%259D%25B4%25EB%25B2%25A4%25ED%258A%25B8_%25EB%25B2%2584%25EB%25B8%2594%25EB%25A7%2581%25EA%25B3%25BC_%25EC%25BA%25A1%25EC%25B2%2598">MDN Web Docs - 이벤트 버블링과 캡처링</a></li>
<li><a href="https://ko.javascript.info/bubbling-and-capturing">Javascript.info - 버블링과 캡처링</a></li>
</ul>
